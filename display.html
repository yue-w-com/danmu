<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Danmu Display</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    .danmu {
      position: absolute;
      white-space: nowrap;
      animation-timing-function: linear;
      animation-fill-mode: forwards;
    }
  </style>
</head>
<body>
<script>
  let TRACK_COUNT = 5;
  let SPEED = 150;
  let FONT_PERCENT = 4;
  let HISTORY_INTERVAL = 4;
  let STATIC_DURATION = 10;
  let STROKE_COLOR = "#000000";
  let STROKE_WIDTH = 1;
  const historyData = [];
  const usedTracks = {
    top: new Set(),
    center: new Set(),
    bottom: new Set()
  };

  const socket = new WebSocket('wss://danmu-backend.onrender.com');

  socket.onmessage = (e) => {
    const d = JSON.parse(e.data);
    if (d.mode === "static") {
      showStaticDanmu(d.text, d.color, d.position || "top");
    } else {
      showDynamicDanmu(d.text, d.color);
    }
    historyData.push(d);
  };

  function showDynamicDanmu(text, color) {
    const el = document.createElement('div');
    el.className = 'danmu';
    el.textContent = text;
    el.style.fontSize = (window.innerHeight * FONT_PERCENT / 100) + 'px';
    el.style.color = color || 'white';
    el.style.textShadow = `-${STROKE_WIDTH}px 0 ${STROKE_COLOR}, ${STROKE_WIDTH}px 0 ${STROKE_COLOR}, 0 -${STROKE_WIDTH}px ${STROKE_COLOR}, 0 ${STROKE_WIDTH}px ${STROKE_COLOR}`;

    const trackHeight = window.innerHeight / TRACK_COUNT;
    const track = Math.floor(Math.random() * tracks); // randomized
// const original_track = showDynamicDanmu.trackIndex = (showDynamicDanmu.trackIndex + 1) % TRACK_COUNT;
    el.style.top = track * trackHeight + 'px';
    el.style.right = '0';
    el.style.left = 'auto';

    document.body.appendChild(el);

    requestAnimationFrame(() => {
      const totalDistance = window.innerWidth + el.offsetWidth;
      const duration = totalDistance / SPEED;
      const animName = 'move_' + Math.random().toString(36).substr(2, 5);
      const style = document.createElement('style');
      style.innerHTML = `@keyframes ${animName} {
        from { transform: translateX(0); }
        to { transform: translateX(-${totalDistance}px); }
      }`;
      document.head.appendChild(style);
      el.style.animation = `${animName} ${duration}s linear forwards`;
    });

    el.addEventListener('animationend', () => el.remove());
  }
  showDynamicDanmu.trackIndex = -1;

  function showStaticDanmu(text, color, position) {
    const el = document.createElement('div');
    el.className = 'danmu';
    el.textContent = text;
    el.style.fontSize = (window.innerHeight * FONT_PERCENT / 100) + 'px';
    el.style.color = color || 'white';
    el.style.left = '50%';
    el.style.transform = 'translate(-50%, 0)';
    el.style.textShadow = `-${STROKE_WIDTH}px 0 ${STROKE_COLOR}, ${STROKE_WIDTH}px 0 ${STROKE_COLOR}, 0 -${STROKE_WIDTH}px ${STROKE_COLOR}, 0 ${STROKE_WIDTH}px ${STROKE_COLOR}`;

    el.style.top = pickUnusedStaticTrack(position) + 'px';

    document.body.appendChild(el);

    setTimeout(() => {
      el.remove();
      usedTracks[position].delete(parseInt(el.style.top));
    }, STATIC_DURATION * 1000);
  }

  function pickUnusedStaticTrack(position) {
    const fullHeight = window.innerHeight;
    const sectionHeight = fullHeight / 3;
    const trackHeight = fullHeight / TRACK_COUNT;
    let baseY = 0;

    if (position === 'top') baseY = 0;
    else if (position === 'center') baseY = sectionHeight;
    else if (position === 'bottom') baseY = sectionHeight * 2;

    let attempts = 0;
    while (attempts < 20) {
      const offset = Math.floor(Math.random() * (sectionHeight / trackHeight));
      const y = Math.floor(baseY + offset * trackHeight);
      if (!usedTracks[position].has(y)) {
        usedTracks[position].add(y);
        return y;
      }
      attempts++;
    }
    return baseY + Math.floor(Math.random() * sectionHeight);
  }

  async function initSettingsAndLoop() {
    const res = await fetch('https://danmu-backend.onrender.com/settings');
    const settings = await res.json();
    TRACK_COUNT = settings.tracks;
    SPEED = settings.speed;
    FONT_PERCENT = settings.fontPercent;
    HISTORY_INTERVAL = settings.historyInterval;
    STATIC_DURATION = settings.staticDuration || 10;
    STROKE_COLOR = settings.strokeColor || "#000000";
    STROKE_WIDTH = settings.strokeWidth || 1;

    const historyRes = await fetch('https://danmu-backend.onrender.com/history');
    const history = await historyRes.json();
    historyData.push(...history);
    loopDanmu();
  }

  function loopDanmu() {
    if (historyData.length > 0) {
      const d = historyData[Math.floor(Math.random() * historyData.length)];
      showDynamicDanmu(d.text, d.color);  // Always use dynamic mode for looped danmu
    }
    fetch('https://danmu-backend.onrender.com/settings')
  .then(res => res.json())
  .then(settings => {
    HISTORY_INTERVAL = settings.historyInterval || 4;
    setTimeout(loopDanmu, HISTORY_INTERVAL * 1000);
  });
  }

  initSettingsAndLoop();
</script>
</body>
</html>
